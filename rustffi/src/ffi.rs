/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const RT_NAME_MAX: u32 = 8;
pub const RT_CPUS_NR: u32 = 1;
pub const RT_ALIGN_SIZE: u32 = 8;
pub const RT_THREAD_PRIORITY_MAX: u32 = 32;
pub const RT_TICK_PER_SECOND: u32 = 1000;
pub const RT_IDLE_HOOK_LIST_SIZE: u32 = 4;
pub const IDLE_THREAD_STACK_SIZE: u32 = 256;
pub const RT_CONSOLEBUF_SIZE: u32 = 128;
pub const RT_CONSOLE_DEVICE_NAME: &[u8; 6] = b"uart1\0";
pub const RT_VER_NUM: u32 = 328192;
pub const RT_BACKTRACE_LEVEL_MAX_NR: u32 = 32;
pub const RT_MAIN_THREAD_STACK_SIZE: u32 = 2048;
pub const RT_MAIN_THREAD_PRIORITY: u32 = 10;
pub const FINSH_THREAD_NAME: &[u8; 7] = b"tshell\0";
pub const FINSH_THREAD_PRIORITY: u32 = 20;
pub const FINSH_THREAD_STACK_SIZE: u32 = 4096;
pub const FINSH_HISTORY_LINES: u32 = 5;
pub const FINSH_CMD_SIZE: u32 = 80;
pub const FINSH_ARG_MAX: u32 = 10;
pub const DFS_FD_MAX: u32 = 16;
pub const DFS_FILESYSTEMS_MAX: u32 = 4;
pub const DFS_FILESYSTEM_TYPES_MAX: u32 = 4;
pub const RT_UNAMED_PIPE_NUMBER: u32 = 64;
pub const RT_LIBC_TZ_DEFAULT_HOUR: u32 = 8;
pub const RT_LIBC_TZ_DEFAULT_MIN: u32 = 0;
pub const RT_LIBC_TZ_DEFAULT_SEC: u32 = 0;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.4.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 4;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 202405;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 202405;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long64: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __NEWLIB_H__: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const ENOMSG: u32 = 35;
pub const EIDRM: u32 = 36;
pub const EDEADLK: u32 = 45;
pub const ENOLCK: u32 = 46;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENOLINK: u32 = 67;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 74;
pub const EBADMSG: u32 = 77;
pub const EFTYPE: u32 = 79;
pub const ENOSYS: u32 = 88;
pub const ENOTEMPTY: u32 = 90;
pub const ENAMETOOLONG: u32 = 91;
pub const ELOOP: u32 = 92;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EAFNOSUPPORT: u32 = 106;
pub const EPROTOTYPE: u32 = 107;
pub const ENOTSOCK: u32 = 108;
pub const ENOPROTOOPT: u32 = 109;
pub const ECONNREFUSED: u32 = 111;
pub const EADDRINUSE: u32 = 112;
pub const ECONNABORTED: u32 = 113;
pub const ENETUNREACH: u32 = 114;
pub const ENETDOWN: u32 = 115;
pub const ETIMEDOUT: u32 = 116;
pub const EHOSTDOWN: u32 = 117;
pub const EHOSTUNREACH: u32 = 118;
pub const EINPROGRESS: u32 = 119;
pub const EALREADY: u32 = 120;
pub const EDESTADDRREQ: u32 = 121;
pub const EMSGSIZE: u32 = 122;
pub const EPROTONOSUPPORT: u32 = 123;
pub const EADDRNOTAVAIL: u32 = 125;
pub const ENETRESET: u32 = 126;
pub const EISCONN: u32 = 127;
pub const ENOTCONN: u32 = 128;
pub const ETOOMANYREFS: u32 = 129;
pub const EDQUOT: u32 = 132;
pub const ESTALE: u32 = 133;
pub const ENOTSUP: u32 = 134;
pub const EILSEQ: u32 = 138;
pub const EOVERFLOW: u32 = 139;
pub const ECANCELED: u32 = 140;
pub const ENOTRECOVERABLE: u32 = 141;
pub const EOWNERDEAD: u32 = 142;
pub const EWOULDBLOCK: u32 = 11;
pub const __ELASTERROR: u32 = 2000;
pub const RT_TRUE: u32 = 1;
pub const RT_FALSE: u32 = 0;
pub const RT_NULL: u32 = 0;
pub const RT_EOK: u32 = 0;
pub const RT_ERROR: u32 = 1;
pub const RT_ETIMEOUT: u32 = 2;
pub const RT_EFULL: u32 = 3;
pub const RT_EEMPTY: u32 = 4;
pub const RT_ENOMEM: u32 = 5;
pub const RT_ENOSYS: u32 = 6;
pub const RT_EBUSY: u32 = 7;
pub const RT_EIO: u32 = 8;
pub const RT_EINTR: u32 = 9;
pub const RT_EINVAL: u32 = 10;
pub const RT_ENOENT: u32 = 11;
pub const RT_ENOSPC: u32 = 12;
pub const RT_EPERM: u32 = 13;
pub const RT_ETRAP: u32 = 14;
pub const RT_EFAULT: u32 = 15;
pub const RT_ENOBUFS: u32 = 16;
pub const RT_ESCHEDISR: u32 = 17;
pub const RT_ESCHEDLOCKED: u32 = 18;
pub const RT_VERSION_MAJOR: u32 = 5;
pub const RT_VERSION_MINOR: u32 = 2;
pub const RT_VERSION_PATCH: u32 = 0;
pub const RT_UINT8_MAX: u32 = 255;
pub const RT_UINT16_MAX: u32 = 65535;
pub const RT_UINT32_MAX: u32 = 4294967295;
pub const RT_UINT64_MAX: i32 = -1;
pub const RT_TICK_MAX: u32 = 4294967295;
pub const RT_SEM_VALUE_MAX: u32 = 65535;
pub const RT_MUTEX_VALUE_MAX: u32 = 65535;
pub const RT_MUTEX_HOLD_MAX: u32 = 255;
pub const RT_MB_ENTRY_MAX: u32 = 65535;
pub const RT_MQ_ENTRY_MAX: u32 = 65535;
pub const RT_EVENT_LENGTH: u32 = 32;
pub const RT_MM_PAGE_SIZE: u32 = 4096;
pub const RT_MM_PAGE_MASK: u32 = 4095;
pub const RT_MM_PAGE_BITS: u32 = 12;
pub const RT_OBJECT_FLAG_MODULE: u32 = 128;
pub const RT_TIMER_FLAG_DEACTIVATED: u32 = 0;
pub const RT_TIMER_FLAG_ACTIVATED: u32 = 1;
pub const RT_TIMER_FLAG_ONE_SHOT: u32 = 0;
pub const RT_TIMER_FLAG_PERIODIC: u32 = 2;
pub const RT_TIMER_FLAG_HARD_TIMER: u32 = 0;
pub const RT_TIMER_FLAG_SOFT_TIMER: u32 = 4;
pub const RT_TIMER_FLAG_THREAD_TIMER: u32 = 8;
pub const RT_TIMER_CTRL_SET_TIME: u32 = 0;
pub const RT_TIMER_CTRL_GET_TIME: u32 = 1;
pub const RT_TIMER_CTRL_SET_ONESHOT: u32 = 2;
pub const RT_TIMER_CTRL_SET_PERIODIC: u32 = 3;
pub const RT_TIMER_CTRL_GET_STATE: u32 = 4;
pub const RT_TIMER_CTRL_GET_REMAIN_TIME: u32 = 5;
pub const RT_TIMER_CTRL_GET_FUNC: u32 = 6;
pub const RT_TIMER_CTRL_SET_FUNC: u32 = 7;
pub const RT_TIMER_CTRL_GET_PARM: u32 = 8;
pub const RT_TIMER_CTRL_SET_PARM: u32 = 9;
pub const RT_TIMER_SKIP_LIST_LEVEL: u32 = 1;
pub const RT_TIMER_SKIP_LIST_MASK: u32 = 3;
pub const RT_THREAD_INIT: u32 = 0;
pub const RT_THREAD_CLOSE: u32 = 1;
pub const RT_THREAD_READY: u32 = 2;
pub const RT_THREAD_RUNNING: u32 = 3;
pub const RT_THREAD_SUSPEND_MASK: u32 = 4;
pub const RT_SIGNAL_COMMON_WAKEUP_MASK: u32 = 2;
pub const RT_SIGNAL_KILL_WAKEUP_MASK: u32 = 1;
pub const RT_THREAD_SUSPEND_INTERRUPTIBLE: u32 = 4;
pub const RT_THREAD_SUSPEND: u32 = 4;
pub const RT_THREAD_SUSPEND_KILLABLE: u32 = 6;
pub const RT_THREAD_SUSPEND_UNINTERRUPTIBLE: u32 = 7;
pub const RT_THREAD_STAT_MASK: u32 = 7;
pub const RT_THREAD_STAT_YIELD: u32 = 8;
pub const RT_THREAD_STAT_YIELD_MASK: u32 = 8;
pub const RT_THREAD_STAT_SIGNAL: u32 = 16;
pub const RT_THREAD_STAT_SIGNAL_READY: u32 = 18;
pub const RT_THREAD_STAT_SIGNAL_WAIT: u32 = 32;
pub const RT_THREAD_STAT_SIGNAL_PENDING: u32 = 64;
pub const RT_THREAD_STAT_SIGNAL_MASK: u32 = 240;
pub const RT_THREAD_CTRL_STARTUP: u32 = 0;
pub const RT_THREAD_CTRL_CLOSE: u32 = 1;
pub const RT_THREAD_CTRL_CHANGE_PRIORITY: u32 = 2;
pub const RT_THREAD_CTRL_INFO: u32 = 3;
pub const RT_THREAD_CTRL_BIND_CPU: u32 = 4;
pub const RT_IPC_FLAG_FIFO: u32 = 0;
pub const RT_IPC_FLAG_PRIO: u32 = 1;
pub const RT_IPC_CMD_UNKNOWN: u32 = 0;
pub const RT_IPC_CMD_RESET: u32 = 1;
pub const RT_IPC_CMD_GET_STATE: u32 = 2;
pub const RT_IPC_CMD_SET_VLIMIT: u32 = 3;
pub const RT_WAITING_FOREVER: i32 = -1;
pub const RT_WAITING_NO: u32 = 0;
pub const RT_EVENT_FLAG_AND: u32 = 1;
pub const RT_EVENT_FLAG_OR: u32 = 2;
pub const RT_EVENT_FLAG_CLEAR: u32 = 4;
pub const RT_DEVICE_FLAG_DEACTIVATE: u32 = 0;
pub const RT_DEVICE_FLAG_RDONLY: u32 = 1;
pub const RT_DEVICE_FLAG_WRONLY: u32 = 2;
pub const RT_DEVICE_FLAG_RDWR: u32 = 3;
pub const RT_DEVICE_FLAG_REMOVABLE: u32 = 4;
pub const RT_DEVICE_FLAG_STANDALONE: u32 = 8;
pub const RT_DEVICE_FLAG_ACTIVATED: u32 = 16;
pub const RT_DEVICE_FLAG_SUSPENDED: u32 = 32;
pub const RT_DEVICE_FLAG_STREAM: u32 = 64;
pub const RT_DEVICE_FLAG_DYNAMIC: u32 = 128;
pub const RT_DEVICE_FLAG_INT_RX: u32 = 256;
pub const RT_DEVICE_FLAG_DMA_RX: u32 = 512;
pub const RT_DEVICE_FLAG_INT_TX: u32 = 1024;
pub const RT_DEVICE_FLAG_DMA_TX: u32 = 2048;
pub const RT_DEVICE_OFLAG_CLOSE: u32 = 0;
pub const RT_DEVICE_OFLAG_RDONLY: u32 = 1;
pub const RT_DEVICE_OFLAG_WRONLY: u32 = 2;
pub const RT_DEVICE_OFLAG_RDWR: u32 = 3;
pub const RT_DEVICE_OFLAG_OPEN: u32 = 8;
pub const RT_DEVICE_OFLAG_MASK: u32 = 3855;
pub const RT_DEVICE_CTRL_RESUME: u32 = 1;
pub const RT_DEVICE_CTRL_SUSPEND: u32 = 2;
pub const RT_DEVICE_CTRL_CONFIG: u32 = 3;
pub const RT_DEVICE_CTRL_CLOSE: u32 = 4;
pub const RT_DEVICE_CTRL_NOTIFY_SET: u32 = 5;
pub const RT_DEVICE_CTRL_SET_INT: u32 = 6;
pub const RT_DEVICE_CTRL_CLR_INT: u32 = 7;
pub const RT_DEVICE_CTRL_GET_INT: u32 = 8;
pub const RT_DEVICE_CTRL_CONSOLE_OFLAG: u32 = 9;
pub const RT_DEVICE_CTRL_MASK: u32 = 31;
pub const RT_CPU_CACHE_LINE_SZ: u32 = 32;
pub const RT_THREAD_RESUME_RES_THR_ERR: i32 = -1;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __int_least8_t = ::core::ffi::c_schar;
pub type __uint_least8_t = ::core::ffi::c_uchar;
pub type __int_least16_t = ::core::ffi::c_short;
pub type __uint_least16_t = ::core::ffi::c_ushort;
pub type __int_least32_t = ::core::ffi::c_int;
pub type __uint_least32_t = ::core::ffi::c_uint;
pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __uint_least64_t = ::core::ffi::c_ulonglong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __intptr_t = ::core::ffi::c_long;
pub type __uintptr_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type int_fast16_t = ::core::ffi::c_short;
pub type uint_fast16_t = ::core::ffi::c_ushort;
pub type int_fast32_t = ::core::ffi::c_int;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
pub type wchar_t = ::core::ffi::c_int;
pub type max_align_t = u128;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type wint_t = ::core::ffi::c_int;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blksize_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
pub type __dev_t = ::core::ffi::c_short;
pub type __uid_t = ::core::ffi::c_ushort;
pub type __gid_t = ::core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ::core::ffi::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::core::ffi::c_long;
pub type _fpos_t = ::core::ffi::c_long;
pub type __size_t = ::core::ffi::c_ulong;
pub type _ssize_t = ::core::ffi::c_long;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::core::ffi::c_uchar; 4usize],
}
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __clock_t = ::core::ffi::c_ulong;
pub type __time_t = ::core::ffi::c_long;
pub type __clockid_t = ::core::ffi::c_ulong;
pub type __daddr_t = ::core::ffi::c_long;
pub type __timer_t = ::core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = ::core::ffi::c_ushort;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __sigset_t = ::core::ffi::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::core::ffi::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 1usize],
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::core::ffi::c_uchar;
pub type u_short = ::core::ffi::c_ushort;
pub type u_int = ::core::ffi::c_uint;
pub type u_long = ::core::ffi::c_ulong;
pub type ushort = ::core::ffi::c_ushort;
pub type uint = ::core::ffi::c_uint;
pub type ulong = ::core::ffi::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::core::ffi::c_ulong;
pub type daddr_t = __daddr_t;
pub type caddr_t = *mut ::core::ffi::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::core::ffi::c_int,
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub stackaddr: *mut ::core::ffi::c_void,
    pub stacksize: ::core::ffi::c_int,
    pub contentionscope: ::core::ffi::c_int,
    pub inheritsched: ::core::ffi::c_int,
    pub schedpolicy: ::core::ffi::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::core::ffi::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub recursive: ::core::ffi::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::core::ffi::c_int,
    pub init_executed: ::core::ffi::c_int,
}
pub type __ULong = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::core::ffi::c_int,
    pub _maxwds: ::core::ffi::c_int,
    pub _sign: ::core::ffi::c_int,
    pub _wds: ::core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::core::ffi::c_int,
    pub __tm_min: ::core::ffi::c_int,
    pub __tm_hour: ::core::ffi::c_int,
    pub __tm_mday: ::core::ffi::c_int,
    pub __tm_mon: ::core::ffi::c_int,
    pub __tm_year: ::core::ffi::c_int,
    pub __tm_wday: ::core::ffi::c_int,
    pub __tm_yday: ::core::ffi::c_int,
    pub __tm_isdst: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut ::core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::core::ffi::c_uchar,
    pub _size: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::core::ffi::c_uchar,
    pub _ur: ::core::ffi::c_int,
    pub _ubuf: [::core::ffi::c_uchar; 3usize],
    pub _nbuf: [::core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::core::ffi::c_int,
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::core::ffi::c_ushort; 3usize],
    pub _mult: [::core::ffi::c_ushort; 3usize],
    pub _add: ::core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::core::ffi::c_int,
    pub _emergency: [::core::ffi::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::core::ffi::c_int,
    pub _cvtbuf: *mut ::core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut ::core::ffi::c_char,
    pub _asctime_buf: [::core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::core::ffi::c_int,
    pub _rand_next: ::core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::core::ffi::c_char; 8usize],
    pub _signal_buf: [::core::ffi::c_char; 24usize],
    pub _getdate_err: ::core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::core::ffi::c_int,
    pub _getlocalename_l_buf: [::core::ffi::c_char; 32usize],
}
#[doc = " RT-Thread basic data types definition"]
pub type rt_bool_t = ::core::ffi::c_int;
pub type rt_int8_t = ::core::ffi::c_schar;
pub type rt_int16_t = ::core::ffi::c_short;
pub type rt_int32_t = ::core::ffi::c_int;
pub type rt_uint8_t = ::core::ffi::c_uchar;
pub type rt_uint16_t = ::core::ffi::c_ushort;
pub type rt_uint32_t = ::core::ffi::c_uint;
pub type rt_int64_t = ::core::ffi::c_longlong;
pub type rt_uint64_t = ::core::ffi::c_ulonglong;
pub type rt_base_t = rt_int32_t;
pub type rt_ubase_t = rt_uint32_t;
pub type rt_size_t = rt_ubase_t;
pub type rt_ssize_t = rt_base_t;
pub type rt_intptr_t = rt_ubase_t;
pub type rt_uintptr_t = rt_base_t;
pub type rt_err_t = rt_base_t;
pub type rt_time_t = rt_uint32_t;
pub type rt_tick_t = rt_uint32_t;
pub type rt_flag_t = rt_base_t;
pub type rt_dev_t = rt_ubase_t;
pub type rt_off_t = rt_base_t;
pub type rt_atomic_t = rt_base_t;
#[doc = " Double List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_list_node {
    #[doc = "< point to next node."]
    pub next: *mut rt_list_node,
    #[doc = "< point to prev node."]
    pub prev: *mut rt_list_node,
}
#[doc = " Double List structure"]
pub type rt_list_t = rt_list_node;
#[doc = " Single List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_slist_node {
    #[doc = "< point to next node."]
    pub next: *mut rt_slist_node,
}
#[doc = " Single List structure"]
pub type rt_slist_t = rt_slist_node;
#[doc = " Lock-less Single List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_lockless_slist_node {
    #[doc = "< point to next node."]
    pub next: rt_atomic_t,
}
#[doc = " Lock-less Single List structure"]
pub type rt_ll_slist_t = rt_lockless_slist_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_spinlock {
    pub critical_level: rt_uint32_t,
    pub lock: rt_ubase_t,
}
pub type rt_spinlock_t = rt_spinlock;
pub type rt_sched_thread_status_t = rt_uint8_t;
#[doc = " Scheduler private status binding on thread. Caller should never accessing\n these members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_sched_thread_priv {
    #[doc = "< thread's initialized tick"]
    pub init_tick: rt_tick_t,
    #[doc = "< remaining tick"]
    pub remaining_tick: rt_tick_t,
    #[doc = "< current priority"]
    pub current_priority: rt_uint8_t,
    #[doc = "< initialized priority"]
    pub init_priority: rt_uint8_t,
    #[doc = "< priority number mask"]
    pub number_mask: rt_uint32_t,
}
#[doc = " Scheduler public status binding on thread. Caller must hold the scheduler\n lock before access any one of its member."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_sched_thread_ctx {
    #[doc = "< node in thread list"]
    pub thread_list_node: rt_list_t,
    #[doc = "< thread status"]
    pub stat: rt_uint8_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< private context of scheduler"]
    pub sched_thread_priv: rt_sched_thread_priv,
}
impl rt_sched_thread_ctx {
    #[inline]
    pub fn sched_flag_locked(&self) -> rt_uint8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sched_flag_locked(&mut self, val: rt_uint8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_flag_locked_raw(this: *const Self) -> rt_uint8_t {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sched_flag_locked_raw(this: *mut Self, val: rt_uint8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sched_flag_ttmr_set(&self) -> rt_uint8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sched_flag_ttmr_set(&mut self, val: rt_uint8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_flag_ttmr_set_raw(this: *const Self) -> rt_uint8_t {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sched_flag_ttmr_set_raw(this: *mut Self, val: rt_uint8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sched_flag_locked: rt_uint8_t,
        sched_flag_ttmr_set: rt_uint8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sched_flag_locked: u8 = unsafe { ::core::mem::transmute(sched_flag_locked) };
            sched_flag_locked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sched_flag_ttmr_set: u8 = unsafe { ::core::mem::transmute(sched_flag_ttmr_set) };
            sched_flag_ttmr_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " System Scheduler Locking"]
pub type rt_sched_lock_level_t = rt_ubase_t;
pub type init_fn_t = ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_int>;
#[doc = " Base structure of Kernel object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_object {
    #[doc = "< dynamic name of kernel object"]
    pub name: [::core::ffi::c_char; 8usize],
    #[doc = "< type of kernel object"]
    pub type_: rt_uint8_t,
    #[doc = "< flag of kernel object"]
    pub flag: rt_uint8_t,
    #[doc = "< list node of kernel object"]
    pub list: rt_list_t,
}
pub type rt_object_t = *mut rt_object;
#[doc = " iterator of rt_object_for_each()\n\n data is the data passing in to rt_object_for_each(). iterator can return\n RT_EOK to continue the iteration; or any positive value to break the loop\n successfully; or any negative errno to break the loop on failure."]
pub type rt_object_iter_t = ::core::option::Option<
    unsafe extern "C" fn(object: rt_object_t, data: *mut ::core::ffi::c_void) -> rt_err_t,
>;
#[doc = "< The object is not used."]
pub const RT_Object_Class_Null: rt_object_class_type = 0;
#[doc = "< The object is a thread."]
pub const RT_Object_Class_Thread: rt_object_class_type = 1;
#[doc = "< The object is a semaphore."]
pub const RT_Object_Class_Semaphore: rt_object_class_type = 2;
#[doc = "< The object is a mutex."]
pub const RT_Object_Class_Mutex: rt_object_class_type = 3;
#[doc = "< The object is a event."]
pub const RT_Object_Class_Event: rt_object_class_type = 4;
#[doc = "< The object is a mail box."]
pub const RT_Object_Class_MailBox: rt_object_class_type = 5;
#[doc = "< The object is a message queue."]
pub const RT_Object_Class_MessageQueue: rt_object_class_type = 6;
#[doc = "< The object is a memory heap."]
pub const RT_Object_Class_MemHeap: rt_object_class_type = 7;
#[doc = "< The object is a memory pool."]
pub const RT_Object_Class_MemPool: rt_object_class_type = 8;
#[doc = "< The object is a device."]
pub const RT_Object_Class_Device: rt_object_class_type = 9;
#[doc = "< The object is a timer."]
pub const RT_Object_Class_Timer: rt_object_class_type = 10;
#[doc = "< The object is a module."]
pub const RT_Object_Class_Module: rt_object_class_type = 11;
#[doc = "< The object is a memory."]
pub const RT_Object_Class_Memory: rt_object_class_type = 12;
#[doc = "< The object is a channel"]
pub const RT_Object_Class_Channel: rt_object_class_type = 13;
#[doc = "< The object is a process group"]
pub const RT_Object_Class_ProcessGroup: rt_object_class_type = 14;
#[doc = "< The object is a session"]
pub const RT_Object_Class_Session: rt_object_class_type = 15;
#[doc = "< The object is a custom object"]
pub const RT_Object_Class_Custom: rt_object_class_type = 16;
#[doc = "< The object is unknown."]
pub const RT_Object_Class_Unknown: rt_object_class_type = 17;
#[doc = "< The object is a static object."]
pub const RT_Object_Class_Static: rt_object_class_type = 128;
#[doc = "  The object type can be one of the follows with specific\n  macros enabled:\n  - Thread\n  - Semaphore\n  - Mutex\n  - Event\n  - MailBox\n  - MessageQueue\n  - MemHeap\n  - MemPool\n  - Device\n  - Timer\n  - Module\n  - Unknown\n  - Static"]
pub type rt_object_class_type = ::core::ffi::c_uint;
#[doc = " The information of the kernel object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_object_information {
    #[doc = "< object class type"]
    pub type_: rt_object_class_type,
    #[doc = "< object list"]
    pub object_list: rt_list_t,
    #[doc = "< object size"]
    pub object_size: rt_size_t,
    pub spinlock: rt_spinlock,
}
#[doc = " timeout handler of rt_timer"]
pub type rt_timer_func_t =
    ::core::option::Option<unsafe extern "C" fn(parameter: *mut ::core::ffi::c_void)>;
#[doc = " timer structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_timer {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    pub row: [rt_list_t; 1usize],
    #[doc = "< timeout function"]
    pub timeout_func: rt_timer_func_t,
    #[doc = "< timeout function's parameter"]
    pub parameter: *mut ::core::ffi::c_void,
    #[doc = "< timer timeout tick"]
    pub init_tick: rt_tick_t,
    #[doc = "< timeout tick"]
    pub timeout_tick: rt_tick_t,
}
pub type rt_timer_t = *mut rt_timer;
pub const RT_INTERRUPTIBLE: _bindgen_ty_1 = 0;
pub const RT_KILLABLE: _bindgen_ty_1 = 1;
pub const RT_UNINTERRUPTIBLE: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
#[doc = " CPU usage statistics data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_cpu_usage_stats {
    pub user: rt_ubase_t,
    pub system: rt_ubase_t,
    pub irq: rt_ubase_t,
    pub idle: rt_ubase_t,
}
pub type rt_cpu_usage_stats_t = *mut rt_cpu_usage_stats;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_cpu {
    pub current_thread: *mut rt_thread,
    pub idle_thread: *mut rt_thread,
}
pub type rt_cpu_t = *mut rt_cpu;
#[doc = " interrupt/exception frame handling\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_interrupt_context {
    #[doc = "< arch specific context"]
    pub context: *mut ::core::ffi::c_void,
    #[doc = "< node for nested interrupt"]
    pub node: rt_slist_t,
}
#[doc = " interrupt/exception frame handling\n"]
pub type rt_interrupt_context_t = *mut rt_interrupt_context;
pub type rt_thread_cleanup_t = ::core::option::Option<unsafe extern "C" fn(tid: *mut rt_thread)>;
#[doc = " Thread structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_thread {
    pub parent: rt_object,
    #[doc = "< stack point"]
    pub sp: *mut ::core::ffi::c_void,
    #[doc = "< entry"]
    pub entry: *mut ::core::ffi::c_void,
    #[doc = "< parameter"]
    pub parameter: *mut ::core::ffi::c_void,
    #[doc = "< stack address"]
    pub stack_addr: *mut ::core::ffi::c_void,
    #[doc = "< stack size"]
    pub stack_size: rt_uint32_t,
    #[doc = "< error code"]
    pub error: rt_err_t,
    pub sched_thread_ctx: rt_sched_thread_ctx,
    #[doc = "< built-in thread timer"]
    pub thread_timer: rt_timer,
    #[doc = "< cleanup function when thread exit"]
    pub cleanup: rt_thread_cleanup_t,
    pub taken_object_list: rt_list_t,
    pub pending_object: rt_object_t,
    pub event_set: rt_uint32_t,
    pub event_info: rt_uint8_t,
    pub spinlock: rt_spinlock,
    #[doc = "< private user data beyond this thread"]
    pub user_data: rt_ubase_t,
}
pub type rt_thread_t = *mut rt_thread;
#[doc = " Base structure of IPC object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_ipc_object {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< threads pended on this resource"]
    pub suspend_thread: rt_list_t,
}
#[doc = " Semaphore structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_semaphore {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< value of semaphore."]
    pub value: rt_uint16_t,
    pub max_value: rt_uint16_t,
    pub spinlock: rt_spinlock,
}
pub type rt_sem_t = *mut rt_semaphore;
#[doc = " Mutual exclusion (mutex) structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mutex {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< the priority ceiling of mutexe"]
    pub ceiling_priority: rt_uint8_t,
    #[doc = "< the maximal priority for pending thread"]
    pub priority: rt_uint8_t,
    #[doc = "< numbers of thread hold the mutex"]
    pub hold: rt_uint8_t,
    #[doc = "< reserved field"]
    pub reserved: rt_uint8_t,
    #[doc = "< current owner of mutex"]
    pub owner: *mut rt_thread,
    #[doc = "< the object list taken by thread"]
    pub taken_list: rt_list_t,
    pub spinlock: rt_spinlock,
}
pub type rt_mutex_t = *mut rt_mutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_event {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< event set"]
    pub set: rt_uint32_t,
    pub spinlock: rt_spinlock,
}
pub type rt_event_t = *mut rt_event;
#[doc = " mailbox structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mailbox {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< start address of message buffer"]
    pub msg_pool: *mut rt_ubase_t,
    #[doc = "< size of message pool"]
    pub size: rt_uint16_t,
    #[doc = "< index of messages in msg_pool"]
    pub entry: rt_uint16_t,
    #[doc = "< input offset of the message buffer"]
    pub in_offset: rt_uint16_t,
    #[doc = "< output offset of the message buffer"]
    pub out_offset: rt_uint16_t,
    #[doc = "< sender thread suspended on this mailbox"]
    pub suspend_sender_thread: rt_list_t,
    pub spinlock: rt_spinlock,
}
pub type rt_mailbox_t = *mut rt_mailbox;
#[doc = " message queue structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_messagequeue {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< start address of message queue"]
    pub msg_pool: *mut ::core::ffi::c_void,
    #[doc = "< message size of each message"]
    pub msg_size: rt_uint16_t,
    #[doc = "< max number of messages"]
    pub max_msgs: rt_uint16_t,
    #[doc = "< index of messages in the queue"]
    pub entry: rt_uint16_t,
    #[doc = "< list head"]
    pub msg_queue_head: *mut ::core::ffi::c_void,
    #[doc = "< list tail"]
    pub msg_queue_tail: *mut ::core::ffi::c_void,
    #[doc = "< pointer indicated the free node of queue"]
    pub msg_queue_free: *mut ::core::ffi::c_void,
    #[doc = "< sender thread suspended on this message queue"]
    pub suspend_sender_thread: rt_list_t,
    pub spinlock: rt_spinlock,
}
pub type rt_mq_t = *mut rt_messagequeue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_memory {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< Memory management algorithm name"]
    pub algorithm: *const ::core::ffi::c_char,
    #[doc = "< memory start address"]
    pub address: rt_ubase_t,
    #[doc = "< memory size"]
    pub total: rt_size_t,
    #[doc = "< size used"]
    pub used: rt_size_t,
    #[doc = "< maximum usage"]
    pub max: rt_size_t,
}
pub type rt_mem_t = *mut rt_memory;
#[doc = " memory item on the heap"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_memheap_item {
    #[doc = "< magic number for memheap"]
    pub magic: rt_uint32_t,
    #[doc = "< point of pool"]
    pub pool_ptr: *mut rt_memheap,
    #[doc = "< next memheap item"]
    pub next: *mut rt_memheap_item,
    #[doc = "< prev memheap item"]
    pub prev: *mut rt_memheap_item,
    #[doc = "< next free memheap item"]
    pub next_free: *mut rt_memheap_item,
    #[doc = "< prev free memheap item"]
    pub prev_free: *mut rt_memheap_item,
}
#[doc = " Base structure of memory heap object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_memheap {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< pool start address and size"]
    pub start_addr: *mut ::core::ffi::c_void,
    #[doc = "< pool size"]
    pub pool_size: rt_size_t,
    #[doc = "< available size"]
    pub available_size: rt_size_t,
    #[doc = "< maximum allocated size"]
    pub max_used_size: rt_size_t,
    #[doc = "< used block list"]
    pub block_list: *mut rt_memheap_item,
    #[doc = "< free block list"]
    pub free_list: *mut rt_memheap_item,
    #[doc = "< free block list header"]
    pub free_header: rt_memheap_item,
    #[doc = "< semaphore lock"]
    pub lock: rt_semaphore,
    #[doc = "< External lock mark"]
    pub locked: rt_bool_t,
}
#[doc = " Base structure of Memory pool object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mempool {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< memory pool start"]
    pub start_address: *mut ::core::ffi::c_void,
    #[doc = "< size of memory pool"]
    pub size: rt_size_t,
    #[doc = "< size of memory blocks"]
    pub block_size: rt_size_t,
    #[doc = "< memory blocks list"]
    pub block_list: *mut rt_uint8_t,
    #[doc = "< numbers of memory block"]
    pub block_total_count: rt_size_t,
    #[doc = "< numbers of free memory block"]
    pub block_free_count: rt_size_t,
    #[doc = "< threads pended on this resource"]
    pub suspend_thread: rt_list_t,
    pub spinlock: rt_spinlock,
}
pub type rt_mp_t = *mut rt_mempool;
#[doc = "< character device"]
pub const RT_Device_Class_Char: rt_device_class_type = 0;
#[doc = "< block device"]
pub const RT_Device_Class_Block: rt_device_class_type = 1;
#[doc = "< net interface"]
pub const RT_Device_Class_NetIf: rt_device_class_type = 2;
#[doc = "< memory device"]
pub const RT_Device_Class_MTD: rt_device_class_type = 3;
#[doc = "< CAN device"]
pub const RT_Device_Class_CAN: rt_device_class_type = 4;
#[doc = "< RTC device"]
pub const RT_Device_Class_RTC: rt_device_class_type = 5;
#[doc = "< Sound device"]
pub const RT_Device_Class_Sound: rt_device_class_type = 6;
#[doc = "< Graphic device"]
pub const RT_Device_Class_Graphic: rt_device_class_type = 7;
#[doc = "< I2C bus device"]
pub const RT_Device_Class_I2CBUS: rt_device_class_type = 8;
#[doc = "< USB slave device"]
pub const RT_Device_Class_USBDevice: rt_device_class_type = 9;
#[doc = "< USB host bus"]
pub const RT_Device_Class_USBHost: rt_device_class_type = 10;
#[doc = "< USB OTG bus"]
pub const RT_Device_Class_USBOTG: rt_device_class_type = 11;
#[doc = "< SPI bus device"]
pub const RT_Device_Class_SPIBUS: rt_device_class_type = 12;
#[doc = "< SPI device"]
pub const RT_Device_Class_SPIDevice: rt_device_class_type = 13;
#[doc = "< SDIO bus device"]
pub const RT_Device_Class_SDIO: rt_device_class_type = 14;
#[doc = "< PM pseudo device"]
pub const RT_Device_Class_PM: rt_device_class_type = 15;
#[doc = "< Pipe device"]
pub const RT_Device_Class_Pipe: rt_device_class_type = 16;
#[doc = "< Portal device"]
pub const RT_Device_Class_Portal: rt_device_class_type = 17;
#[doc = "< Timer device"]
pub const RT_Device_Class_Timer: rt_device_class_type = 18;
#[doc = "< Miscellaneous device"]
pub const RT_Device_Class_Miscellaneous: rt_device_class_type = 19;
#[doc = "< Sensor device"]
pub const RT_Device_Class_Sensor: rt_device_class_type = 20;
#[doc = "< Touch device"]
pub const RT_Device_Class_Touch: rt_device_class_type = 21;
#[doc = "< PHY device"]
pub const RT_Device_Class_PHY: rt_device_class_type = 22;
#[doc = "< Security device"]
pub const RT_Device_Class_Security: rt_device_class_type = 23;
#[doc = "< WLAN device"]
pub const RT_Device_Class_WLAN: rt_device_class_type = 24;
#[doc = "< Pin device"]
pub const RT_Device_Class_Pin: rt_device_class_type = 25;
#[doc = "< ADC device"]
pub const RT_Device_Class_ADC: rt_device_class_type = 26;
#[doc = "< DAC device"]
pub const RT_Device_Class_DAC: rt_device_class_type = 27;
#[doc = "< WDT device"]
pub const RT_Device_Class_WDT: rt_device_class_type = 28;
#[doc = "< PWM device"]
pub const RT_Device_Class_PWM: rt_device_class_type = 29;
#[doc = "< Bus device"]
pub const RT_Device_Class_Bus: rt_device_class_type = 30;
#[doc = "< unknown device"]
pub const RT_Device_Class_Unknown: rt_device_class_type = 31;
#[doc = " device (I/O) class type"]
pub type rt_device_class_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_driver {
    _unused: [u8; 0],
}
pub type rt_driver_t = *mut rt_driver;
pub type rt_device_t = *mut rt_device;
#[doc = " WaitQueue structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_wqueue {
    pub flag: rt_uint32_t,
    pub waiting_list: rt_list_t,
    pub spinlock: rt_spinlock,
}
#[doc = " WaitQueue structure"]
pub type rt_wqueue_t = rt_wqueue;
#[doc = " Device structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< device type"]
    pub type_: rt_device_class_type,
    #[doc = "< device flag"]
    pub flag: rt_uint16_t,
    #[doc = "< device open flag"]
    pub open_flag: rt_uint16_t,
    #[doc = "< reference count"]
    pub ref_count: rt_uint8_t,
    #[doc = "< 0 - 255"]
    pub device_id: rt_uint8_t,
    pub rx_indicate:
        ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t, size: rt_size_t) -> rt_err_t>,
    pub tx_complete: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, buffer: *mut ::core::ffi::c_void) -> rt_err_t,
    >,
    pub init: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t,
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *mut ::core::ffi::c_void,
            size: rt_size_t,
        ) -> rt_ssize_t,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *const ::core::ffi::c_void,
            size: rt_size_t,
        ) -> rt_ssize_t,
    >,
    pub control: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            cmd: ::core::ffi::c_int,
            args: *mut ::core::ffi::c_void,
        ) -> rt_err_t,
    >,
    pub readlink: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            buf: *mut ::core::ffi::c_char,
            len: ::core::ffi::c_int,
        ) -> rt_err_t,
    >,
    #[doc = "< device private data"]
    pub user_data: *mut ::core::ffi::c_void,
}
#[doc = " Notify structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_notify {
    pub notify: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t)>,
    pub dev: *mut rt_device,
}
pub const RT_HW_CACHE_FLUSH: RT_HW_CACHE_OPS = 1;
pub const RT_HW_CACHE_INVALIDATE: RT_HW_CACHE_OPS = 2;
pub type RT_HW_CACHE_OPS = ::core::ffi::c_uint;
pub type rt_isr_handler_t = ::core::option::Option<
    unsafe extern "C" fn(vector: ::core::ffi::c_int, param: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_irq_desc {
    pub handler: rt_isr_handler_t,
    pub param: *mut ::core::ffi::c_void,
}
#[doc = " Hardware Layer Backtrace Service"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_hw_backtrace_frame {
    pub fp: rt_uintptr_t,
    pub pc: rt_uintptr_t,
}
pub type syscall_func = ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_long>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct finsh_syscall {
    pub name: *const ::core::ffi::c_char,
    pub desc: *const ::core::ffi::c_char,
    pub opt: *mut msh_cmd_opt,
    pub func: syscall_func,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct finsh_syscall_item {
    pub next: *mut finsh_syscall_item,
    pub syscall: finsh_syscall,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msh_cmd_opt {
    pub id: rt_uint32_t,
    pub name: *const ::core::ffi::c_char,
    pub des: *const ::core::ffi::c_char,
}
pub type msh_cmd_opt_t = msh_cmd_opt;
#[doc = " @brief Sets a hook function when a thread is initialized.\n\n @param thread is the target thread that initializing"]
pub type rt_thread_inited_hookproto_t =
    ::core::option::Option<unsafe extern "C" fn(thread: rt_thread_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mq_message {
    pub next: *mut rt_mq_message,
    pub length: rt_ssize_t,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::core::ffi::c_uint,
    pub fp_offset: ::core::ffi::c_uint,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
unsafe extern "C" {
    pub fn select(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
    pub fn pselect(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::core::ffi::c_int;
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
    pub fn __retarget_lock_close(lock: _LOCK_T);
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> ::core::ffi::c_int;
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> ::core::ffi::c_int;
    pub fn __retarget_lock_release(lock: _LOCK_T);
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
    pub static mut __sf: [__FILE; 3usize];
    pub static mut __sglue: _glue;
    pub static mut _impure_ptr: *mut _reent;
    pub static mut _impure_data: _reent;
    pub static mut __atexit: *mut _atexit;
    pub static mut __atexit0: _atexit;
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
    pub fn _reclaim_reent(arg1: *mut _reent);
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> ::core::ffi::c_int,
        >,
        arg3: *mut _glue,
    ) -> ::core::ffi::c_int;
    pub fn __errno() -> *mut ::core::ffi::c_int;
    pub static _sys_errlist: [*const ::core::ffi::c_char; 0usize];
    pub static mut _sys_nerr: ::core::ffi::c_int;
    pub fn rt_sched_lock(plvl: *mut rt_sched_lock_level_t) -> rt_err_t;
    pub fn rt_sched_unlock(level: rt_sched_lock_level_t) -> rt_err_t;
    pub fn rt_sched_unlock_n_resched(level: rt_sched_lock_level_t) -> rt_err_t;
    pub fn rt_sched_is_locked() -> rt_bool_t;
    pub fn rt_get_errno() -> rt_err_t;
    pub fn rt_set_errno(no: rt_err_t);
    pub fn _rt_errno() -> *mut ::core::ffi::c_int;
    pub fn rt_strerror(error: rt_err_t) -> *const ::core::ffi::c_char;
    pub fn rt_hw_cpu_icache_enable();
    pub fn rt_hw_cpu_icache_disable();
    pub fn rt_hw_cpu_icache_status() -> rt_base_t;
    pub fn rt_hw_cpu_icache_ops(
        ops: ::core::ffi::c_int,
        addr: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_int,
    );
    pub fn rt_hw_cpu_dcache_enable();
    pub fn rt_hw_cpu_dcache_disable();
    pub fn rt_hw_cpu_dcache_status() -> rt_base_t;
    pub fn rt_hw_cpu_dcache_ops(
        ops: ::core::ffi::c_int,
        addr: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_int,
    );
    pub fn rt_hw_cpu_reset();
    pub fn rt_hw_cpu_shutdown();
    pub fn rt_hw_cpu_arch() -> *const ::core::ffi::c_char;
    pub fn rt_hw_stack_init(
        entry: *mut ::core::ffi::c_void,
        parameter: *mut ::core::ffi::c_void,
        stack_addr: *mut rt_uint8_t,
        exit: *mut ::core::ffi::c_void,
    ) -> *mut rt_uint8_t;
    pub fn rt_hw_interrupt_init();
    pub fn rt_hw_interrupt_mask(vector: ::core::ffi::c_int);
    pub fn rt_hw_interrupt_umask(vector: ::core::ffi::c_int);
    pub fn rt_hw_interrupt_install(
        vector: ::core::ffi::c_int,
        handler: rt_isr_handler_t,
        param: *mut ::core::ffi::c_void,
        name: *const ::core::ffi::c_char,
    ) -> rt_isr_handler_t;
    pub fn rt_hw_interrupt_uninstall(
        vector: ::core::ffi::c_int,
        handler: rt_isr_handler_t,
        param: *mut ::core::ffi::c_void,
    );
    pub fn rt_hw_interrupt_disable() -> rt_base_t;
    pub fn rt_hw_interrupt_enable(level: rt_base_t);
    pub fn rt_hw_interrupt_is_disabled() -> rt_bool_t;
    pub fn rt_hw_context_switch(from: rt_ubase_t, to: rt_ubase_t);
    pub fn rt_hw_context_switch_to(to: rt_ubase_t);
    pub fn rt_hw_context_switch_interrupt(
        from: rt_ubase_t,
        to: rt_ubase_t,
        from_thread: rt_thread_t,
        to_thread: rt_thread_t,
    );
    pub fn rt_hw_backtrace_frame_get(
        thread: rt_thread_t,
        frame: *mut rt_hw_backtrace_frame,
    ) -> rt_err_t;
    pub fn rt_hw_backtrace_frame_unwind(
        thread: rt_thread_t,
        frame: *mut rt_hw_backtrace_frame,
    ) -> rt_err_t;
    pub fn rt_hw_console_output(str_: *const ::core::ffi::c_char);
    pub fn rt_hw_show_memory(addr: rt_uint32_t, size: rt_size_t);
    pub fn rt_hw_exception_install(
        exception_handle: ::core::option::Option<
            unsafe extern "C" fn(context: *mut ::core::ffi::c_void) -> rt_err_t,
        >,
    );
    pub fn rt_hw_us_delay(us: rt_uint32_t);
    pub fn rt_hw_cpu_id() -> ::core::ffi::c_int;
    pub fn rt_hw_atomic_load(ptr: *mut rt_atomic_t) -> rt_atomic_t;
    pub fn rt_hw_atomic_store(ptr: *mut rt_atomic_t, val: rt_atomic_t);
    pub fn rt_hw_atomic_add(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
    pub fn rt_hw_atomic_sub(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
    pub fn rt_hw_atomic_and(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
    pub fn rt_hw_atomic_or(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
    pub fn rt_hw_atomic_xor(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
    pub fn rt_hw_atomic_exchange(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
    pub fn rt_hw_atomic_flag_clear(ptr: *mut rt_atomic_t);
    pub fn rt_hw_atomic_flag_test_and_set(ptr: *mut rt_atomic_t) -> rt_atomic_t;
    pub fn rt_hw_atomic_compare_exchange_strong(
        ptr: *mut rt_atomic_t,
        expected: *mut rt_atomic_t,
        desired: rt_atomic_t,
    ) -> rt_atomic_t;
    pub fn rt_memset(
        src: *mut ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        n: rt_ubase_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn rt_memcpy(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        n: rt_ubase_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn rt_memmove(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        n: rt_size_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn rt_memcmp(
        cs: *const ::core::ffi::c_void,
        ct: *const ::core::ffi::c_void,
        count: rt_size_t,
    ) -> rt_int32_t;
    pub fn rt_strdup(s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn rt_strnlen(s: *const ::core::ffi::c_char, maxlen: rt_ubase_t) -> rt_size_t;
    pub fn rt_strstr(
        str1: *const ::core::ffi::c_char,
        str2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn rt_strcasecmp(
        a: *const ::core::ffi::c_char,
        b: *const ::core::ffi::c_char,
    ) -> rt_int32_t;
    pub fn rt_strcpy(
        dst: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn rt_strncpy(
        dest: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        n: rt_size_t,
    ) -> *mut ::core::ffi::c_char;
    pub fn rt_strncmp(
        cs: *const ::core::ffi::c_char,
        ct: *const ::core::ffi::c_char,
        count: rt_size_t,
    ) -> rt_int32_t;
    pub fn rt_strcmp(cs: *const ::core::ffi::c_char, ct: *const ::core::ffi::c_char) -> rt_int32_t;
    pub fn rt_strlen(src: *const ::core::ffi::c_char) -> rt_size_t;
    pub fn rt_vsprintf(
        dest: *mut ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        arg_ptr: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn rt_vsnprintf(
        buf: *mut ::core::ffi::c_char,
        size: rt_size_t,
        fmt: *const ::core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn rt_sprintf(
        buf: *mut ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn rt_snprintf(
        buf: *mut ::core::ffi::c_char,
        size: rt_size_t,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn rt_vsscanf(
        buffer: *const ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn rt_sscanf(
        str_: *const ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn msh_opt_list_dump(options: *mut ::core::ffi::c_void);
    pub fn msh_cmd_opt_id_get(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
        options: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub static mut global_syscall_list: *mut finsh_syscall_item;
    pub static mut _syscall_table_begin: *mut finsh_syscall;
    pub static mut _syscall_table_end: *mut finsh_syscall;
    pub fn finsh_syscall_next(call: *mut finsh_syscall) -> *mut finsh_syscall;
    pub fn finsh_set_device(device_name: *const ::core::ffi::c_char);
    pub fn entry() -> ::core::ffi::c_int;
    #[doc = " @addtogroup group_KernelObject\n @{"]
    pub fn rt_object_get_information(type_: rt_object_class_type) -> *mut rt_object_information;
    pub fn rt_object_get_length(type_: rt_object_class_type) -> ::core::ffi::c_int;
    pub fn rt_object_get_pointers(
        type_: rt_object_class_type,
        pointers: *mut rt_object_t,
        maxlen: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn rt_object_init(
        object: *mut rt_object,
        type_: rt_object_class_type,
        name: *const ::core::ffi::c_char,
    );
    pub fn rt_object_detach(object: rt_object_t);
    pub fn rt_object_allocate(
        type_: rt_object_class_type,
        name: *const ::core::ffi::c_char,
    ) -> rt_object_t;
    pub fn rt_object_delete(object: rt_object_t);
    pub fn rt_custom_object_create(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_void,
        data_destroy: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> rt_err_t,
        >,
    ) -> rt_object_t;
    pub fn rt_custom_object_destroy(obj: rt_object_t) -> rt_err_t;
    pub fn rt_object_is_systemobject(object: rt_object_t) -> rt_bool_t;
    pub fn rt_object_get_type(object: rt_object_t) -> rt_uint8_t;
    pub fn rt_object_for_each(
        type_: rt_uint8_t,
        iter: rt_object_iter_t,
        data: *mut ::core::ffi::c_void,
    ) -> rt_err_t;
    pub fn rt_object_find(name: *const ::core::ffi::c_char, type_: rt_uint8_t) -> rt_object_t;
    pub fn rt_object_get_name(
        object: rt_object_t,
        name: *mut ::core::ffi::c_char,
        name_size: rt_uint8_t,
    ) -> rt_err_t;
    pub fn rt_object_attach_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
    pub fn rt_object_detach_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
    pub fn rt_object_trytake_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
    pub fn rt_object_take_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
    pub fn rt_object_put_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
    #[doc = " @addtogroup group_Clock\n @{"]
    pub fn rt_tick_get() -> rt_tick_t;
    pub fn rt_tick_set(tick: rt_tick_t);
    pub fn rt_tick_increase();
    pub fn rt_tick_increase_tick(tick: rt_tick_t);
    pub fn rt_tick_from_millisecond(ms: rt_int32_t) -> rt_tick_t;
    pub fn rt_tick_get_millisecond() -> rt_tick_t;
    pub fn rt_tick_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>);
    pub fn rt_system_timer_init();
    pub fn rt_system_timer_thread_init();
    pub fn rt_timer_init(
        timer: rt_timer_t,
        name: *const ::core::ffi::c_char,
        timeout: ::core::option::Option<unsafe extern "C" fn(parameter: *mut ::core::ffi::c_void)>,
        parameter: *mut ::core::ffi::c_void,
        time: rt_tick_t,
        flag: rt_uint8_t,
    );
    pub fn rt_timer_detach(timer: rt_timer_t) -> rt_err_t;
    pub fn rt_timer_create(
        name: *const ::core::ffi::c_char,
        timeout: ::core::option::Option<unsafe extern "C" fn(parameter: *mut ::core::ffi::c_void)>,
        parameter: *mut ::core::ffi::c_void,
        time: rt_tick_t,
        flag: rt_uint8_t,
    ) -> rt_timer_t;
    pub fn rt_timer_delete(timer: rt_timer_t) -> rt_err_t;
    pub fn rt_timer_start(timer: rt_timer_t) -> rt_err_t;
    pub fn rt_timer_stop(timer: rt_timer_t) -> rt_err_t;
    pub fn rt_timer_control(
        timer: rt_timer_t,
        cmd: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
    ) -> rt_err_t;
    pub fn rt_timer_next_timeout_tick() -> rt_tick_t;
    pub fn rt_timer_check();
    pub fn rt_timer_enter_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(timer: *mut rt_timer)>,
    );
    pub fn rt_timer_exit_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(timer: *mut rt_timer)>,
    );
    #[doc = " @addtogroup group_Thread\n @{"]
    pub fn rt_thread_init(
        thread: *mut rt_thread,
        name: *const ::core::ffi::c_char,
        entry: ::core::option::Option<unsafe extern "C" fn(parameter: *mut ::core::ffi::c_void)>,
        parameter: *mut ::core::ffi::c_void,
        stack_start: *mut ::core::ffi::c_void,
        stack_size: rt_uint32_t,
        priority: rt_uint8_t,
        tick: rt_uint32_t,
    ) -> rt_err_t;
    pub fn rt_thread_detach(thread: rt_thread_t) -> rt_err_t;
    pub fn rt_thread_create(
        name: *const ::core::ffi::c_char,
        entry: ::core::option::Option<unsafe extern "C" fn(parameter: *mut ::core::ffi::c_void)>,
        parameter: *mut ::core::ffi::c_void,
        stack_size: rt_uint32_t,
        priority: rt_uint8_t,
        tick: rt_uint32_t,
    ) -> rt_thread_t;
    pub fn rt_thread_delete(thread: rt_thread_t) -> rt_err_t;
    pub fn rt_thread_close(thread: rt_thread_t) -> rt_err_t;
    pub fn rt_thread_self() -> rt_thread_t;
    pub fn rt_thread_find(name: *mut ::core::ffi::c_char) -> rt_thread_t;
    pub fn rt_thread_startup(thread: rt_thread_t) -> rt_err_t;
    pub fn rt_thread_yield() -> rt_err_t;
    pub fn rt_thread_delay(tick: rt_tick_t) -> rt_err_t;
    pub fn rt_thread_delay_until(tick: *mut rt_tick_t, inc_tick: rt_tick_t) -> rt_err_t;
    pub fn rt_thread_mdelay(ms: rt_int32_t) -> rt_err_t;
    pub fn rt_thread_control(
        thread: rt_thread_t,
        cmd: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
    ) -> rt_err_t;
    pub fn rt_thread_suspend(thread: rt_thread_t) -> rt_err_t;
    pub fn rt_thread_suspend_with_flag(
        thread: rt_thread_t,
        suspend_flag: ::core::ffi::c_int,
    ) -> rt_err_t;
    pub fn rt_thread_resume(thread: rt_thread_t) -> rt_err_t;
    pub fn rt_thread_get_name(
        thread: rt_thread_t,
        name: *mut ::core::ffi::c_char,
        name_size: rt_uint8_t,
    ) -> rt_err_t;
    pub fn rt_thread_suspend_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(thread: rt_thread_t)>,
    );
    pub fn rt_thread_resume_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(thread: rt_thread_t)>,
    );
    pub fn rt_thread_idle_init();
    pub fn rt_thread_idle_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>)
        -> rt_err_t;
    pub fn rt_thread_idle_delhook(hook: ::core::option::Option<unsafe extern "C" fn()>)
        -> rt_err_t;
    pub fn rt_thread_idle_gethandler() -> rt_thread_t;
    pub fn rt_system_scheduler_init();
    pub fn rt_system_scheduler_start();
    pub fn rt_schedule();
    pub fn rt_scheduler_do_irq_switch(context: *mut ::core::ffi::c_void);
    pub fn rt_scheduler_stack_check(thread: *mut rt_thread);
    pub fn rt_enter_critical() -> rt_base_t;
    pub fn rt_exit_critical();
    pub fn rt_exit_critical_safe(critical_level: rt_base_t);
    pub fn rt_critical_level() -> rt_uint16_t;
    pub fn rt_scheduler_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(from: rt_thread_t, to: rt_thread_t)>,
    );
    pub fn rt_scheduler_switch_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(tid: *mut rt_thread)>,
    );
    pub fn rt_mp_init(
        mp: *mut rt_mempool,
        name: *const ::core::ffi::c_char,
        start: *mut ::core::ffi::c_void,
        size: rt_size_t,
        block_size: rt_size_t,
    ) -> rt_err_t;
    pub fn rt_mp_detach(mp: *mut rt_mempool) -> rt_err_t;
    pub fn rt_mp_create(
        name: *const ::core::ffi::c_char,
        block_count: rt_size_t,
        block_size: rt_size_t,
    ) -> rt_mp_t;
    pub fn rt_mp_delete(mp: rt_mp_t) -> rt_err_t;
    pub fn rt_mp_alloc(mp: rt_mp_t, time: rt_int32_t) -> *mut ::core::ffi::c_void;
    pub fn rt_mp_free(block: *mut ::core::ffi::c_void);
    pub fn rt_mp_alloc_sethook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(mp: *mut rt_mempool, block: *mut ::core::ffi::c_void),
        >,
    );
    pub fn rt_mp_free_sethook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(mp: *mut rt_mempool, block: *mut ::core::ffi::c_void),
        >,
    );
    pub fn rt_system_heap_init(
        begin_addr: *mut ::core::ffi::c_void,
        end_addr: *mut ::core::ffi::c_void,
    );
    pub fn rt_system_heap_init_generic(
        begin_addr: *mut ::core::ffi::c_void,
        end_addr: *mut ::core::ffi::c_void,
    );
    pub fn rt_malloc(size: rt_size_t) -> *mut ::core::ffi::c_void;
    pub fn rt_free(ptr: *mut ::core::ffi::c_void);
    pub fn rt_realloc(
        ptr: *mut ::core::ffi::c_void,
        newsize: rt_size_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn rt_calloc(count: rt_size_t, size: rt_size_t) -> *mut ::core::ffi::c_void;
    pub fn rt_malloc_align(size: rt_size_t, align: rt_size_t) -> *mut ::core::ffi::c_void;
    pub fn rt_free_align(ptr: *mut ::core::ffi::c_void);
    pub fn rt_memory_info(total: *mut rt_size_t, used: *mut rt_size_t, max_used: *mut rt_size_t);
    pub fn rt_malloc_sethook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut *mut ::core::ffi::c_void, size: rt_size_t),
        >,
    );
    pub fn rt_realloc_set_entry_hook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut *mut ::core::ffi::c_void, size: rt_size_t),
        >,
    );
    pub fn rt_realloc_set_exit_hook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut *mut ::core::ffi::c_void, size: rt_size_t),
        >,
    );
    pub fn rt_free_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(ptr: *mut *mut ::core::ffi::c_void)>,
    );
    #[doc = " memory heap object interface"]
    pub fn rt_memheap_init(
        memheap: *mut rt_memheap,
        name: *const ::core::ffi::c_char,
        start_addr: *mut ::core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_err_t;
    pub fn rt_memheap_detach(heap: *mut rt_memheap) -> rt_err_t;
    pub fn rt_memheap_alloc(heap: *mut rt_memheap, size: rt_size_t) -> *mut ::core::ffi::c_void;
    pub fn rt_memheap_realloc(
        heap: *mut rt_memheap,
        ptr: *mut ::core::ffi::c_void,
        newsize: rt_size_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn rt_memheap_free(ptr: *mut ::core::ffi::c_void);
    pub fn rt_memheap_info(
        heap: *mut rt_memheap,
        total: *mut rt_size_t,
        used: *mut rt_size_t,
        max_used: *mut rt_size_t,
    );
    #[doc = " memory heap as heap"]
    pub fn _memheap_alloc(heap: *mut rt_memheap, size: rt_size_t) -> *mut ::core::ffi::c_void;
    pub fn _memheap_free(rmem: *mut ::core::ffi::c_void);
    pub fn _memheap_realloc(
        heap: *mut rt_memheap,
        rmem: *mut ::core::ffi::c_void,
        newsize: rt_size_t,
    ) -> *mut ::core::ffi::c_void;
    #[doc = " Suspend list - A basic building block for IPC primitives which interacts with\n                scheduler directly. Its API is similar to a FIFO list.\n\n Note: don't use in application codes directly"]
    pub fn rt_susp_list_print(list: *mut rt_list_t);
    pub fn rt_susp_list_dequeue(
        susp_list: *mut rt_list_t,
        thread_error: rt_err_t,
    ) -> *mut rt_thread;
    pub fn rt_susp_list_resume_all(susp_list: *mut rt_list_t, thread_error: rt_err_t) -> rt_err_t;
    pub fn rt_susp_list_resume_all_irq(
        susp_list: *mut rt_list_t,
        thread_error: rt_err_t,
        lock: *mut rt_spinlock,
    ) -> rt_err_t;
    pub fn rt_thread_suspend_to_list(
        thread: rt_thread_t,
        susp_list: *mut rt_list_t,
        ipc_flags: ::core::ffi::c_int,
        suspend_flag: ::core::ffi::c_int,
    ) -> rt_err_t;
    pub fn rt_susp_list_enqueue(
        susp_list: *mut rt_list_t,
        thread: rt_thread_t,
        ipc_flags: ::core::ffi::c_int,
    ) -> rt_err_t;
    pub fn rt_sem_init(
        sem: rt_sem_t,
        name: *const ::core::ffi::c_char,
        value: rt_uint32_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
    pub fn rt_sem_detach(sem: rt_sem_t) -> rt_err_t;
    pub fn rt_sem_create(
        name: *const ::core::ffi::c_char,
        value: rt_uint32_t,
        flag: rt_uint8_t,
    ) -> rt_sem_t;
    pub fn rt_sem_delete(sem: rt_sem_t) -> rt_err_t;
    pub fn rt_sem_take(sem: rt_sem_t, timeout: rt_int32_t) -> rt_err_t;
    pub fn rt_sem_take_interruptible(sem: rt_sem_t, timeout: rt_int32_t) -> rt_err_t;
    pub fn rt_sem_take_killable(sem: rt_sem_t, timeout: rt_int32_t) -> rt_err_t;
    pub fn rt_sem_trytake(sem: rt_sem_t) -> rt_err_t;
    pub fn rt_sem_release(sem: rt_sem_t) -> rt_err_t;
    pub fn rt_sem_control(
        sem: rt_sem_t,
        cmd: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
    ) -> rt_err_t;
    pub fn rt_mutex_init(
        mutex: rt_mutex_t,
        name: *const ::core::ffi::c_char,
        flag: rt_uint8_t,
    ) -> rt_err_t;
    pub fn rt_mutex_detach(mutex: rt_mutex_t) -> rt_err_t;
    pub fn rt_mutex_create(name: *const ::core::ffi::c_char, flag: rt_uint8_t) -> rt_mutex_t;
    pub fn rt_mutex_delete(mutex: rt_mutex_t) -> rt_err_t;
    pub fn rt_mutex_drop_thread(mutex: rt_mutex_t, thread: rt_thread_t);
    pub fn rt_mutex_setprioceiling(mutex: rt_mutex_t, priority: rt_uint8_t) -> rt_uint8_t;
    pub fn rt_mutex_getprioceiling(mutex: rt_mutex_t) -> rt_uint8_t;
    pub fn rt_mutex_take(mutex: rt_mutex_t, timeout: rt_int32_t) -> rt_err_t;
    pub fn rt_mutex_trytake(mutex: rt_mutex_t) -> rt_err_t;
    pub fn rt_mutex_take_interruptible(mutex: rt_mutex_t, time: rt_int32_t) -> rt_err_t;
    pub fn rt_mutex_take_killable(mutex: rt_mutex_t, time: rt_int32_t) -> rt_err_t;
    pub fn rt_mutex_release(mutex: rt_mutex_t) -> rt_err_t;
    pub fn rt_mutex_control(
        mutex: rt_mutex_t,
        cmd: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
    ) -> rt_err_t;
    pub fn rt_event_init(
        event: rt_event_t,
        name: *const ::core::ffi::c_char,
        flag: rt_uint8_t,
    ) -> rt_err_t;
    pub fn rt_event_detach(event: rt_event_t) -> rt_err_t;
    pub fn rt_event_create(name: *const ::core::ffi::c_char, flag: rt_uint8_t) -> rt_event_t;
    pub fn rt_event_delete(event: rt_event_t) -> rt_err_t;
    pub fn rt_event_send(event: rt_event_t, set: rt_uint32_t) -> rt_err_t;
    pub fn rt_event_recv(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
    pub fn rt_event_recv_interruptible(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
    pub fn rt_event_recv_killable(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
    pub fn rt_event_control(
        event: rt_event_t,
        cmd: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
    ) -> rt_err_t;
    pub fn rt_mb_init(
        mb: rt_mailbox_t,
        name: *const ::core::ffi::c_char,
        msgpool: *mut ::core::ffi::c_void,
        size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
    pub fn rt_mb_detach(mb: rt_mailbox_t) -> rt_err_t;
    pub fn rt_mb_create(
        name: *const ::core::ffi::c_char,
        size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_mailbox_t;
    pub fn rt_mb_delete(mb: rt_mailbox_t) -> rt_err_t;
    pub fn rt_mb_send(mb: rt_mailbox_t, value: rt_ubase_t) -> rt_err_t;
    pub fn rt_mb_send_interruptible(mb: rt_mailbox_t, value: rt_ubase_t) -> rt_err_t;
    pub fn rt_mb_send_killable(mb: rt_mailbox_t, value: rt_ubase_t) -> rt_err_t;
    pub fn rt_mb_send_wait(mb: rt_mailbox_t, value: rt_ubase_t, timeout: rt_int32_t) -> rt_err_t;
    pub fn rt_mb_send_wait_interruptible(
        mb: rt_mailbox_t,
        value: rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
    pub fn rt_mb_send_wait_killable(
        mb: rt_mailbox_t,
        value: rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
    pub fn rt_mb_urgent(mb: rt_mailbox_t, value: rt_ubase_t) -> rt_err_t;
    pub fn rt_mb_recv(mb: rt_mailbox_t, value: *mut rt_ubase_t, timeout: rt_int32_t) -> rt_err_t;
    pub fn rt_mb_recv_interruptible(
        mb: rt_mailbox_t,
        value: *mut rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
    pub fn rt_mb_recv_killable(
        mb: rt_mailbox_t,
        value: *mut rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
    pub fn rt_mb_control(
        mb: rt_mailbox_t,
        cmd: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
    ) -> rt_err_t;
    pub fn rt_mq_init(
        mq: rt_mq_t,
        name: *const ::core::ffi::c_char,
        msgpool: *mut ::core::ffi::c_void,
        msg_size: rt_size_t,
        pool_size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
    pub fn rt_mq_detach(mq: rt_mq_t) -> rt_err_t;
    pub fn rt_mq_create(
        name: *const ::core::ffi::c_char,
        msg_size: rt_size_t,
        max_msgs: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_mq_t;
    pub fn rt_mq_delete(mq: rt_mq_t) -> rt_err_t;
    pub fn rt_mq_send(mq: rt_mq_t, buffer: *const ::core::ffi::c_void, size: rt_size_t)
        -> rt_err_t;
    pub fn rt_mq_send_interruptible(
        mq: rt_mq_t,
        buffer: *const ::core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_err_t;
    pub fn rt_mq_send_killable(
        mq: rt_mq_t,
        buffer: *const ::core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_err_t;
    pub fn rt_mq_send_wait(
        mq: rt_mq_t,
        buffer: *const ::core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
    pub fn rt_mq_send_wait_interruptible(
        mq: rt_mq_t,
        buffer: *const ::core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
    pub fn rt_mq_send_wait_killable(
        mq: rt_mq_t,
        buffer: *const ::core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
    pub fn rt_mq_urgent(
        mq: rt_mq_t,
        buffer: *const ::core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_err_t;
    pub fn rt_mq_recv(
        mq: rt_mq_t,
        buffer: *mut ::core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_ssize_t;
    pub fn rt_mq_recv_interruptible(
        mq: rt_mq_t,
        buffer: *mut ::core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_ssize_t;
    pub fn rt_mq_recv_killable(
        mq: rt_mq_t,
        buffer: *mut ::core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_ssize_t;
    pub fn rt_mq_control(
        mq: rt_mq_t,
        cmd: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
    ) -> rt_err_t;
    #[doc = "@}"]
    pub fn rt_thread_defunct_init();
    pub fn rt_thread_defunct_enqueue(thread: rt_thread_t);
    pub fn rt_thread_defunct_dequeue() -> rt_thread_t;
    pub fn rt_defunct_execute();
    pub fn rt_spin_lock_init(lock: *mut rt_spinlock);
    pub fn rt_spin_lock(lock: *mut rt_spinlock);
    pub fn rt_spin_unlock(lock: *mut rt_spinlock);
    pub fn rt_spin_lock_irqsave(lock: *mut rt_spinlock) -> rt_base_t;
    pub fn rt_spin_unlock_irqrestore(lock: *mut rt_spinlock, level: rt_base_t);
    #[doc = " @addtogroup group_Device\n @{"]
    pub fn rt_device_find(name: *const ::core::ffi::c_char) -> rt_device_t;
    pub fn rt_device_register(
        dev: rt_device_t,
        name: *const ::core::ffi::c_char,
        flags: rt_uint16_t,
    ) -> rt_err_t;
    pub fn rt_device_unregister(dev: rt_device_t) -> rt_err_t;
    pub fn rt_device_create(
        type_: ::core::ffi::c_int,
        attach_size: ::core::ffi::c_int,
    ) -> rt_device_t;
    pub fn rt_device_destroy(device: rt_device_t);
    pub fn rt_device_set_rx_indicate(
        dev: rt_device_t,
        rx_ind: ::core::option::Option<
            unsafe extern "C" fn(dev: rt_device_t, size: rt_size_t) -> rt_err_t,
        >,
    ) -> rt_err_t;
    pub fn rt_device_set_tx_complete(
        dev: rt_device_t,
        tx_done: ::core::option::Option<
            unsafe extern "C" fn(dev: rt_device_t, buffer: *mut ::core::ffi::c_void) -> rt_err_t,
        >,
    ) -> rt_err_t;
    pub fn rt_device_init(dev: rt_device_t) -> rt_err_t;
    pub fn rt_device_open(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t;
    pub fn rt_device_close(dev: rt_device_t) -> rt_err_t;
    pub fn rt_device_read(
        dev: rt_device_t,
        pos: rt_off_t,
        buffer: *mut ::core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_ssize_t;
    pub fn rt_device_write(
        dev: rt_device_t,
        pos: rt_off_t,
        buffer: *const ::core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_ssize_t;
    pub fn rt_device_control(
        dev: rt_device_t,
        cmd: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
    ) -> rt_err_t;
    pub fn rt_interrupt_enter();
    pub fn rt_interrupt_leave();
    pub fn rt_interrupt_context_push(this_ctx: rt_interrupt_context_t);
    pub fn rt_interrupt_context_pop();
    pub fn rt_interrupt_context_get() -> *mut ::core::ffi::c_void;
    #[doc = " CPU object"]
    pub fn rt_cpu_self() -> *mut rt_cpu;
    pub fn rt_cpu_index(index: ::core::ffi::c_int) -> *mut rt_cpu;
    pub fn rt_interrupt_get_nest() -> rt_uint8_t;
    pub fn rt_interrupt_enter_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>);
    pub fn rt_interrupt_leave_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>);
    pub fn rt_components_init();
    pub fn rt_components_board_init();
    pub fn rt_kprintf(fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn rt_kputs(str_: *const ::core::ffi::c_char);
    pub fn rt_backtrace() -> rt_err_t;
    pub fn rt_backtrace_thread(thread: rt_thread_t) -> rt_err_t;
    pub fn rt_backtrace_frame(thread: rt_thread_t, frame: *mut rt_hw_backtrace_frame) -> rt_err_t;
    pub fn rt_backtrace_formatted_print(
        buffer: *mut rt_ubase_t,
        buflen: ::core::ffi::c_long,
    ) -> rt_err_t;
    pub fn rt_backtrace_to_buffer(
        thread: rt_thread_t,
        frame: *mut rt_hw_backtrace_frame,
        skip: ::core::ffi::c_long,
        buffer: *mut rt_ubase_t,
        buflen: ::core::ffi::c_long,
    ) -> rt_err_t;
    pub fn rt_console_set_device(name: *const ::core::ffi::c_char) -> rt_device_t;
    pub fn rt_console_get_device() -> rt_device_t;
    pub fn __rt_ffs(value: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn __rt_ffsl(value: ::core::ffi::c_ulong) -> ::core::ffi::c_ulong;
    pub fn __rt_clz(value: ::core::ffi::c_ulong) -> ::core::ffi::c_ulong;
    pub fn rt_show_version();
    pub static mut rt_assert_hook: ::core::option::Option<
        unsafe extern "C" fn(
            ex: *const ::core::ffi::c_char,
            func: *const ::core::ffi::c_char,
            line: rt_size_t,
        ),
    >;
    pub fn rt_assert_set_hook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(
                ex: *const ::core::ffi::c_char,
                func: *const ::core::ffi::c_char,
                line: rt_size_t,
            ),
        >,
    );
    pub fn rt_assert_handler(
        ex: *const ::core::ffi::c_char,
        func: *const ::core::ffi::c_char,
        line: rt_size_t,
    );
}
